# JVM-垃圾收集器与内存分配策略

### 一，标记对象是生存还是死亡

#### 1，引用计数法

+ 给对象添加一个计数器，每当有一个地方引用它时，计数器值就加1，当引用失效的时候，计数器就减1.当任何时刻为0的时候对象就不在使用。
+ 优点：实现简单，判定效率也高。
+ 缺点：难以解决对象之家相互循环引用的问题。

#### 2，可达性分析算法

+ 该算法的基本思路就是从一系列成为GC Root的对象为起始点，从这些节点开始向下搜索，搜索走过的路径成为引用链，当一个对象不在引用链上的时候，就说明该对象是不可用的。
+ GC Roots对象包含以下几种：
  + 虚拟机栈中引用的对象
  + 方法区中类静态属性引用的对象
  + 方法区中常量引用的对象
  + 本地方法栈中引用的对象
+ 回收方法区中类的情况(下面的条件必须同时满足)
  + 该1所有的实例已经被回收，不存在类的实例对象
  + 加载该类的ClassLoader已经被回收
  + 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类。

#### 3，垃圾回收算法

​	标记清除法，复制算法，标记整理法

+ 标记清除法
  + 首先标记要回收的对象，然后再统一回收被标记的对象。
  + 缺点
    + 效率问题：标记和清除两者的效率都不是的很高
    + 空间问题：标记清楚之后会产生内存碎片，当分配的对象所占内存空间较大的时候，会造成空间的浪费。
+ 复制算法(适用于新生代)
  + 将内存按照容量划分为大小相等的两块，每次只使用其中的一块，当当前内存块用完之后，就将还存活的对象复制到另一个内存块中，然后再将当前内存块清理掉。
  + 实际上是将内存分成了一个较大的Eden区，和两块较小Survivor区，每次使用Eden区和一块Survivor区，当回收的时候，就将Eden区和Survivor区中的东西复制到另一个Survivor区中。
+ 标记整理法(适用于老年代)
  + 将存户的对象都想一端移动，然后清理掉边界以外的内存。
+ 分代收集算法
  + 只是将内存按照对象的存活周期分成了几个区域，对于新生代(对象的存活率较低)来说：一般采用复制算法，对于老年代(对象的存活率较高)来说，一般采用标记-整理法或者标记-清除算法。

+ 长期存活的对象将进入老年代，每次GC之后，对象的年龄就增加一岁，一般来说，当年龄达到15岁(默认值)之后，就将晋升为老年代。
+ 大对象直接进入老年代

​		

