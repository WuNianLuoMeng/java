# 线程安全问题

### 1，什么是线程安全问题

​	多个线程访问一个对象，不考虑这些线程在运行环境下的调度和交替运行，也不需要进行额外的同步，或者调用方进行其他的协调操作，调用这个对象的行为都可以获得正确的结果。那么这个对象是线程安全的。

### 2，有什么办法来保证线程的安全问题

+ **使用synchronized关键字**

  该关键字主要对类对象，类方法，和对Object类型的字段加锁。

+ 对类方法进行加锁(对象锁)

  ​	当多个线程调用同一个对象实例的方法时，synchronized会对该对象实例进行加锁，使得每一时刻保证只有一个线程在使用这个对象实例。如果不加锁的话，那么多个线程将会一起使用这个对象实例。但是其他线程可以访问非synchronized的方法，因为那些方法不需要获取对象的锁。

  ~~~ java
  import java.util.concurrent.ExecutionException;
  
  public class T1 {
      public static void main(String[] args) {
          Test1 x = new Test1();
          new Thread("Thread1") {
              @Override
              public void run() {
                  x.T();               
              }
          }.start();
          new Thread("Thread2") {
              @Override
              public void run() {
                  x.T();
              }
          }.start();
      }
  
  }
  
  class Test1 {
      public synchronized void T() {
          for (int i = 1; i <= 5; i++)
          {
              System.out.println(Thread.currentThread().getName() + "调用T方法" + i + "次");
          }
      }
  }
  ~~~

+ 对Object对象加锁(对代码块加锁)

  ​	对于这种方式，它的锁粒度是要小于上面的那种方式的，因为这种方式只是锁了一个代码块，不会锁住整个方法。

  ~~~ java
  import java.util.concurrent.ExecutionException;
  
  public class _T2 {
      public static void main(String[] args) {
          Test2 x = new Test2();
          new Thread("Thread1") {
              @Override
              public void run() {
                  x.T();
              }
          }.start();
          new Thread("Thread2") {
              @Override
              public void run() {
                  x.T();
              }
          }.start();
      }
  
  }
  
  class Test2 {
      final Object obj = new Object();
      public void T() {
          System.out.println(Thread.currentThread().getName()+"使用");
          synchronized (this) {
              for (int i = 1; i <= 5; i++) {
                  System.out.println(Thread.currentThread().getName() + "调用了T方法" + i + "次");
              }
          }
      }
  }
  ~~~

  运行结果：

  Thread1使用
  Thread1调用了T方法1次
  Thread1调用了T方法2次
  Thread2使用(这个就是由于synchronized锁的不是整个方法，其他进程是可以进入到该方法中，但是不可以进入到方法块内)
  Thread1调用了T方法3次
  Thread1调用了T方法4次
  Thread1调用了T方法5次
  Thread2调用了T方法1次
  Thread2调用了T方法2次
  Thread2调用了T方法3次
  Thread2调用了T方法4次
  Thread2调用了T方法5次

+ 对类对象进行加锁(对那些用static修饰的方法加锁)

  ​	每个类都有class锁，它是对于那些synchronized static 修饰而言的，当一个线程调用非static的方法时，与调用static方法的线程之间并不会产生互斥关系，因为一个用的是对象锁，一个用的是class锁，两者之间并没有互斥的关系。

  ~~~ java
  public class _T3{
      public static void main(String[] args){
  
          Test3 x=new Test3();
  
          new Thread("Thread1"){
              @Override
              public void run() {
                  Test3.T1();
              }
          }.start();
          new Thread("Thread2"){
              @Override
              public void run() {
                  x.t();
              }
          }.start();
          new Thread("Thread3"){
            @Override
            public void run() {
                Test3.T2();
            }  
          }.start();
  
      }
  }
  class Test3{
      public synchronized static void T1(){
          for(int i=1;i<=100;i++){
              System.out.println(Thread.currentThread().getName()+"调用了T1方法"+i+"次");
          }       
      }
      public synchronized static void T2(){
          for(int i=1;i<=2;i++){
              System.out.println(Thread.currentThread().getName()+"调用了T2方法"+i+"次");
          }
      }
      public void t(){
          for(int i=1;i<=100;i++){
              System.out.println(Thread.currentThread().getName()+"调用了t方法"+i+"次");
          }
      }
  }
  ~~~



  结果中可以看出只有当Thread1完成之后，Thread3才开始执行。而Thread1并不会影响Thread2的执行，因为Thread2使用的是对象锁。